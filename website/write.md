# Writing a Julia Package

In Julia, packages are the natural medium for code that doesn't fit in a simple script.
While this might sound excessive at first, it provides many conveniences.

This page serves as a guide for creating your first Julia package. 
It walks you through the process of the initial setup and the structure of a Julia package. 

~~~
<div class="admonition tip">
  <p class="admonition-title">Tip</p>
  <p>As an alternative to this page, we highly recommend reading 
  <a href="https://modernjuliaworkflows.github.io/sharing/">Modern Julia Workflows</a>. 
  The <i>"Sharing"</i> section can be considered a version of this page for advanced users.</p>
</div>
~~~

~~~
<h2>Table of Contents</h2>
~~~
\tableofcontents


TODO: replace blue boxes

## Setting up a Package

### PkgTemplates.jl
[PkgTemplates.jl](https://github.com/JuliaCI/PkgTemplates.jl) 
is a highly configurable package for project templates.
Thanks to these templates, setting up the file structure for a Julia package takes seconds.  

We suggest you use the following template for your project work:

```julia
using PkgTemplates

template = Template(;
    user="YourGitHubUsername",
    authors="Firstname Lastname <YourEmail@campus.tu-berlin.de>",
    julia=v"1.6",
    plugins=[
        License(; name="MIT"),
        Git(; manifest=false),
        GitHubActions(; x64=true),
        Codecov(),
        Documenter{GitHubActions}(),
    ],
)
```

Make sure the `user` and `authors` fields reflect your GitHub account name and authorship details.

`julia=v"1.6"` sets the minimum Julia version requirement to 1.6 for package compatibility.
We chose 1.6 because it is the last Long-term support (LTS) release.

Regarding the plugins within the `plugins` array:
- `License(name="MIT")` applies the MIT License for open-source distribution with minimal restrictions.
- `Git(manifest=false)` configures the use of Git while opting out of tracking the `Manifest.toml` file.
- `GitHubActions()` sets up continuous integration (CI) via GitHub Actions with default parameters.
- `Codecov()`sets up CodeCov for assessing code coverage, which quantifies the proportion of source code exercised by tests.
- `Documenter{GitHubActions}()` includes Documenter for generating package documentation, 
   with the `GitHubActions` specifier indicating deployment to GitHub Pages via GitHubActions.

After you created the template, run 
```julia-repl
julia> template("MyPackage")
```

At the end of the package generation, 
Julia will inform us that our project has been created in the `~/.julia/dev` folder:

```julia-repl
[ Info: New package is at ~/.julia/dev/MyPackage
```

~~~
<div class="admonition tip">
  <p class="admonition-title">Tip</p>
  <p>The template suggested above is recommended for the JuML project work at TU Berlin.</p>
  <p>Take a look at the
  <a href="https://juliaci.github.io/PkgTemplates.jl/stable/user/">PkgTemplates user guide</a>
  to create a template customized to your needs.
</p>
</div>
~~~

### File structure
Let's take a look at the structure of the files generated by PkgTemplates.jl:
```bash
$ cd ~/.julia/dev/MyPackage

$ tree -a # show folder structure
.
├── .github
│   └── workflows
│       ├── CI.yml
│       ├── CompatHelper.yml
│       └── TagBot.yml
├── .gitignore
├── LICENSE
├── Manifest.toml
├── Project.toml
├── README.md
├── src
│   └── MyPackage.jl
└── test
    └── runtests.jl

5 directories, 10 files
```

~~~
<div class="admonition note">
  <p class="admonition-title">Note</p>
  <p>
    In the lecture we will be discussing all files in detail:
    <ul>
      <li>
        <code>Project.toml</code> for packages
        <ul>
          <li>compat entries</li>
          <li>semantic versioning</li>
        </ul>
      </li>
      <li>structure of Julia source code</li>
      <li>package testing</li>
      <li>continuous integration (CI)</li>
    </ul>
  </p>
</div>
~~~

### Activating the package environment
#### In VSCode
The Julia VSCode extension provides a keyboard shortcut to start a REPL: `Alt+j Alt+o` (`option+j option+o` on macOS).

#### In the REPL
To start a REPL session that directly activates your local project environment,
start julia with the flag `--project`:
```bash
$ cd ~/.julia/dev/MyProject

$ julia --project
```

```julia-repl
# Starts Julia REPL session
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.8.5 (2023-01-08)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia> # press ]

(MyPackage) pkg> # project environment is active!
```

The environment is directly active, there is no need to type `activate MyPackage`.

~~~
<div class="admonition tip">
  <p class="admonition-title">Tip</p>
  <p>I recommend setting a shell alias set for 
  <code>julia --project --banner=no</code>.</p>
</div>
~~~

### `Project.toml` in packages
Let's add a dependency to our package, for example CSV.jl:

```julia-repl
(MyPackage) pkg> add CSV
    Updating registry at `~/.julia/registries/General.toml`
   Resolving package versions...
    Updating `~/.julia/dev/MyPackage/Project.toml`
  [336ed68f] + CSV v0.10.10
    Updating `~/.julia/dev/MyPackage/Manifest.toml`
  [336ed68f] + CSV v0.10.10
  [944b1d66] + CodecZlib v0.7.1
  [9a962f9c] + DataAPI v1.15.0
  [e2d170a0] + DataValueInterfaces v1.0.0
  [48062228] + FilePathsBase v0.9.20
  [842dd82b] + InlineStrings v1.4.0
  [82899510] + IteratorInterfaceExtensions v1.0.0
  [2dfb63ee] + PooledArrays v1.4.2
  [91c51154] + SentinelArrays v1.3.18
  [3783bdb8] + TableTraits v1.0.1
  [bd369af6] + Tables v1.10.1
  [3bb67fe8] + TranscodingStreams v0.9.13
  [ea10d353] + WeakRefStrings v1.4.2
  [76eceee3] + WorkerUtilities v1.6.1
  [9fa8497b] + Future
  [8dfed614] + Test
```

When adding a package, the `Project.toml` of our package will automatically be updated.
It is always located in the root folder of the package
(in our example at `~/.julia/dev/MyPackage/Project.toml`).

In our case, the `Project.toml` contains:

```toml
name = "MyPackage"
uuid = "c97c58cb-c2b5-45a4-93b4-32bd8ab523c1"
authors = ["Adrian Hill <git@adrianhill.de> and contributors"]
version = "1.0.0-DEV"

[deps]
CSV = "336ed68f-0bac-5ca0-87d4-7b16caf5d00b"

[compat]
julia = "1"

[extras]
Test = "8dfed614-e22c-5e08-85e1-65c5234f0b40"

[targets]
test = ["Test"]
```

- our package has a name, a UUID, a version and information
  about the package author
- adding CSV.jl created an entry in the dependency section `[deps]`
- there is a new `[compat]` section to specify package compatibility bounds
   - compat entries for external packages like CSV.jl have to be added manually
- we have an "extra" dependency on the package Tests.jl (more on this later)

~~~
<div class="admonition tip">
  <p class="admonition-title">Tip</p>
  <p>When looking at a new package, 
  checking out its dependencies in the <code>Project.toml</code> is a good starting point.</p>
</div>
~~~

### Structure of the source folder
By convention, the *"main"* file of a project has the same name as the project.
PkgTemplates already created this file `src/MyPackage.jl` for us: 
```julia
# Contents of src/MyPackage.jl
module MyPackage

# Write your package code here.

end
```
The file defines a module with the same name as our package.
Inside this module, you will import dependencies, `include` other source files and export your functions. 
Let's look at a toy example:

```julia
# Updated contents of src/MyPackage.jl
module MyPackage

# 1.) Import functions you need
using LinearAlgebra: cholesky 

# 2.) Include source files
include("my_source_code_1.jl")
include("my_source_code_2.jl")
include("my_source_code_3.jl")

# 3.) Export functions you defined
export my_function_1, my_function_2

end # end module
```

~~~
<div class="admonition tip">
  <p class="admonition-title">Tip</p>
  <p>When looking at the source code of a package, 
  this should be the first file you read.</p>
</div>
~~~

### Package tests
By convention, package tests are in a folder called `test/`.
The main file that includes all other tests is called `runtest.jl`.
To run this file, enter Pkg-mode and write `test`: 
```julia-repl
(MyPackage) pkg> test
     Testing MyPackage
      Status `/private/var/folders/74/wcz8c9qs5dzc8wgkk7839k5c0000gn/T/jl_TcJkwR/Project.toml`

     ... # Julia resolves a temporary environment from scratch
    
     Testing Running tests...
Test Summary: |Time
MyPackage.jl  | None  0.0s
     Testing MyPackage tests passed
```

Our tests passed since we didn't have any!

Using the [Test.jl](https://docs.julialang.org/en/v1/stdlib/Test/) 
standard library package and its macros `@test` and `@testset`, 
we can add tests to our package, which will be demonstrated in the lecture.

~~~
<div class="admonition note">
  <p class="admonition-title">Note</p>
  <p>
    Package tests will be covered in the lecture. Take a look at the 
    <a href="https://docs.julialang.org/en/v1/stdlib/Test/">unit test documentation</a>.
  </p>
</div>
~~~

### Continuous integration
The `.github/workflows/` folder contains three files, which specify 
[*GitHub actions*](https://github.com/features/actions):
- `CI.yml`: run tests, optionally build docs and determine code coverage.
- `CompatHelper.yml`: Check whether `[compat]` entries are up to date.
- `TagBot.yml`: tag new releases of your package.

These files contain instructions that will be run on GitHub's computers.
The most basic use-case is running package tests. 
GitHub Actions either run on a timed schedule or at specific events, 
for example when pushing commits and opening pull requests.

~~~
<div class="admonition note">
  <p class="admonition-title">Note</p>
  <p>GitHub Actions and CI will be showcased in the lecture.</p>
</div>
~~~

### Package registration
If you wrote a high quality, well tested package 
and want to make it available to all Julia users through the package manager, 
follow the [Registrator.jl instructions](https://github.com/JuliaRegistries/Registrator.jl). 

People will then be able to install your package by writing

```julia-repl
(@v1.8) pkg> add MyPackage
```

## Writing Your Code
### Source Directory
Create any required files within the `src/` directory. 
Ensure that the main file, named after your package (e.g., `MyPackage.jl`),  
has an `include` statement for all necessary files while also `export`ing all functions that you develop. 
For further guidance, consult the lecture materials.

### Testing
#### Test Cases (`test/runtests.jl`)
Create comprehensive test cases in `test/runtests.jl` to validate all functionalities of your package. 
The code coverage will be automatically calculated after every commit using CodeCov.

#### Running Tests locally
To execute tests manually, open the terminal, navigate to your package directory, 
start Julia, enter package mode (by typing `]`), and execute the `test` command.


## References
- [Modern Julia Workflows](https://modernjuliaworkflows.github.io/sharing/)
  is a must read for every Julia user
- [PkgTemplates.jl documentation](https://juliaci.github.io/PkgTemplates.jl/stable/user/)
