<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/julia-ml-course/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/julia-ml-course/css/franklin.css"> <link rel=stylesheet  href="/julia-ml-course/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/julia-ml-course/assets/favicon.png"> <title>Julia for Machine Learning</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/julia-ml-course/">JuML</a></h1> <p class=lead > Julia Programming<br> for Machine Learning<br> SoSe 2025 @ TU Berlin.</p> </div> <div class=sidebar-nav-section >Course overview</div> <a class="sidebar-nav-item " href="/julia-ml-course/">General Information</a> <a class="sidebar-nav-item " href="/julia-ml-course/E1_Installation/">Installation</a> <a class="sidebar-nav-item " href="/julia-ml-course/E2_Help/">Getting Help</a> <div class=sidebar-nav-section >Julia basics</div> <a class="sidebar-nav-item " href="/julia-ml-course/L1_Basics_1/">Types, Functions & MD</a> <a class="sidebar-nav-item " href="/julia-ml-course/L2_Basics_2/">Arrays & Linear Algebra</a> <a class="sidebar-nav-item " href="/julia-ml-course/L4_Basics_3/">Custom Types</a> <div class=sidebar-nav-section >Julia ecosystem</div> <a class="sidebar-nav-item " href="/julia-ml-course/L3_Plotting/">Plotting & DataFrames</a> <a class="sidebar-nav-item " href="/julia-ml-course/L5_Machine_Learning/">Machine Learning</a> <a class="sidebar-nav-item " href="/julia-ml-course/L6_Automatic_Differentiation/">Automatic Differentiation</a> <a class="sidebar-nav-item " href="/julia-ml-course/L7_Deep_Learning/">Deep Learning</a> <div class=sidebar-nav-section >Workflows</div> <a class="sidebar-nav-item " href="/julia-ml-course/overview/">Overview</a> <a class="sidebar-nav-item " href="/julia-ml-course/environments/">Environments</a> <a class="sidebar-nav-item " href="/julia-ml-course/repl/">Enhancing the REPL</a> <a class="sidebar-nav-item " href="/julia-ml-course/setup/">Setting up a Package</a> <a class="sidebar-nav-item " href="/julia-ml-course/write/">Writing a Package</a> <a class="sidebar-nav-item " href="/julia-ml-course/test/">Testing</a> <a class="sidebar-nav-item " href="/julia-ml-course/git/">Hosting on GitHub</a> <a class="sidebar-nav-item " href="/julia-ml-course/docs/">Documentation</a> <a class="sidebar-nav-item " href="/julia-ml-course/debugging/">Debugging</a> <a class="sidebar-nav-item active" href="/julia-ml-course/profiling/">Profiling</a> <a class="sidebar-nav-item " href="/julia-ml-course/scripts/">Scripts & Experiments</a> <a class="sidebar-nav-item " href="/julia-ml-course/common-mistakes/">Common Mistakes</a> <div class=sidebar-nav-section >Homework</div> <a class="sidebar-nav-item " href="/julia-ml-course/H1_Basics/">Week 1</a> <a class="sidebar-nav-item " href="/julia-ml-course/H2_Linear_Algebra/">Week 2</a> <a class="sidebar-nav-item " href="/julia-ml-course/H3_Custom_Types/">Week 3</a> <a class="sidebar-nav-item " href="/julia-ml-course/H4_Deep_Learning/">Week 4</a> </nav> <br> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id=profiling ><a href="#profiling" class=header-anchor >Profiling </a></h1> <p>In this lesson, we are going to take a look at debugging and profiling. Since type inference is central to writing performant Julia code, we will also take a look at how to fix inference problems.</p> <p>We will demonstrate both the Julia VSCode extension and editor-agnostic packages.</p> <p> <h2>Table of Contents</h2> <div class=franklin-toc ><ol><li><a href="#vscode_extension">VSCode extension</a><li><a href="#importance_of_type_inference">Importance of type inference</a><li><a href="#profileviewjl">ProfileView.jl</a><li><a href="#type_stability">Type stability</a><ol><li><a href="#code_warntype"><code>@code_warntype</code></a><li><a href="#cthulhujl">Cthulhu.jl</a></ol><li><a href="#acknowledgements">Acknowledgements</a></ol></div></p> <p>To demonstrate profiling, we are going to use an example from the <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> documentation:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> profile_test(n)
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
        A = randn(<span class=hljs-number >100</span>,<span class=hljs-number >100</span>,<span class=hljs-number >20</span>)
        m = maximum(A)
        Am = mapslices(sum, A; dims=<span class=hljs-number >2</span>)
        B = A[:,:,<span class=hljs-number >5</span>]
        Bsort = mapslices(sort, B; dims=<span class=hljs-number >1</span>)
        b = rand(<span class=hljs-number >100</span>)
        C = B.*b
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <p>Note that this function runs the inner computation <code>n</code>-times to obtain a more accurate profile.</p> <h2 id=vscode_extension ><a href="#vscode_extension" class=header-anchor >VSCode extension</a></h2> <p>To run the profiler from the Julia VSCode extension, simply call your code using the <code>@profview</code> macro. It is recommended to call this twice: once to trigger compilation and once to obtain the actual profile:</p> <pre><code class="julia hljs"><span class=hljs-meta >@profview</span> profile_test(<span class=hljs-number >1</span>)  <span class=hljs-comment ># run once to trigger compilation (ignore this one)</span>
<span class=hljs-meta >@profview</span> profile_test(<span class=hljs-number >10</span>) <span class=hljs-comment ># measure runtime</span></code></pre> <p><img src="/julia-ml-course/assets/vscode_profile.png" alt="VSCode profiling" /></p> <p>After calling the macro &#40;point 1&#41;, our code is highlighted by a bar plot, indicating how much time is spent in each line of code &#40;point 2&#41;.</p> <p>A more detailed view on this can be found in the profiler window. After selecting the relevant thread &#40;point 3&#41;, we can inspect the flame graph of our function call &#40;point 4&#41;.</p> <p>Vertically, this graph visualizes the call stack of our function, with the &quot;root&quot; function call at the top and &quot;leaves&quot; at the bottom. Hovering your mouse over a block will indicate the function name, as well as its source file and corresponding line number.</p> <p>The duration of each function call is visualized by the horizontal space each block takes up in the graph. On this machine, most time was spent allocating the large random matrix <code>A</code>.</p> <p>The color of the blocks also contains information:</p> <ul> <li><p>Yellow indicates calls to the garbage collector. If you see many of these, you might want to use <code>@views</code> instead of allocating memory.</p> <li><p>Red indicates <em>run-time dispatch</em>: the Julia compiler can&#39;t infer which types a function is going to encounter before actually running the code. We will see how to fix these using Cthulhu.jl at the end of this lecture.</p> </ul> <h2 id=importance_of_type_inference ><a href="#importance_of_type_inference" class=header-anchor >Importance of type inference</a></h2> <p>Let&#39;s take a look at a second example &#40;<a href="https://github.com/timholy/ProfileView.jl">taken from ProfileView.jl</a>&#41; to highlight the importance of type inference:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> profile_test_sort(n, len=<span class=hljs-number >100000</span>)
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
        list = []
        <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:len
            push!(list, rand())
        <span class=hljs-keyword >end</span>
        sort!(list)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >1</span>)  <span class=hljs-comment ># run once to trigger compilation (ignore this one)</span>
<span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >10</span>) <span class=hljs-comment ># measure runtime</span></code></pre> <p>Since <code>list &#61; &#91;&#93;</code> is of type <code>Vector&#123;Any&#125;</code>, Julia can&#39;t infer its type. This is also visible in the profile, which looks fragmented and contains many red blocks:</p> <p><img src="/julia-ml-course/assets/vscode_profile_stab_1.png" alt="VSCode type inference 1" /></p> <p>As expected, the function is quite slow:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>  0.442308 seconds (1.00 M allocations: 41.165 MiB, 1.31% gc time)</code></pre> <p>By changing the third line to <code>list &#61; Float64&#91;&#93;</code>, the Julia compiler can infer that it is working with a <code>Vector&#123;Float64&#125;</code> and generate more performant code. We can see in the profiler that the generated code is much simpler and type stable: </p> <p><img src="/julia-ml-course/assets/vscode_profile_stab_2.png" alt="VSCode type inference 2" /></p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@time</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>  0.034384 seconds (140 allocations: 25.986 MiB, 14.58% gc time)</code></pre> <p>This corresponds to a 10x increase in performance&#33;</p> <h2 id=profileviewjl ><a href="#profileviewjl" class=header-anchor >ProfileView.jl</a></h2> <p>Instead of using VSCode, we can make use of <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> to profile our code, which uses the same <code>@profview</code> macro:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> ProfileView
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> profile_test_sort(n, len=<span class=hljs-number >100000</span>)
           <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:n
               list = []
               <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:len
                   push!(list, rand())
               <span class=hljs-keyword >end</span>
               sort!(list)
           <span class=hljs-keyword >end</span>
       <span class=hljs-keyword >end</span>
</span>profile_test_sort (generic function with 1 method)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >1</span>)
</span>Gtk.GtkWindowLeaf(...)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-meta >@profview</span> profile_test_sort(<span class=hljs-number >10</span>)
</span>Gtk.GtkWindowLeaf(...)</code></pre> <p>This will open a new GTK window with the profile. The only difference to VSCode is that the flame graph is flipped vertically:</p> <p><img src="/julia-ml-course/assets/profileview_2.png" alt="ProfileView.jl output" /></p> <h2 id=type_stability ><a href="#type_stability" class=header-anchor >Type stability</a></h2> <p>Since we&#39;ve seen how important type inference is for performance, we are going to demonstrate two tools that help us find inference problems.</p> <p>For this purpose, we are going to use an example from the <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> documentation:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo()
    T = rand() &gt; <span class=hljs-number >0.5</span> ? <span class=hljs-built_in >Int64</span> : <span class=hljs-built_in >Float64</span>
    sum(rand(T, <span class=hljs-number >100</span>))
<span class=hljs-keyword >end</span></code></pre> <p>This function &quot;flips a coin&quot; to determine whether <code>T</code> is the type <code>Int64</code> or <code>Float64</code>. It then samples 100 numbers of type <code>T</code> and sums them up. This is obviously type unstable, since Julia can&#39;t infer types before running the function.</p> <h3 id=code_warntype ><a href="#code_warntype" class=header-anchor ><code>@code_warntype</code></a></h3> <p>The output of <code>@code_warntype</code> is similar to to that of <code>@code_lowered</code>, which printed the <em>intermediate representation</em> &#40;IR&#41; of our Julia code. However, <code>@code_warntype</code> additionally shows type information:</p> <p><img src="/julia-ml-course/assets/code_warntype_2.png" alt="@code_warntype example" /></p> <p>We can see type-stable statements in blue/cyan: </p> <ul> <li><p><code>rand&#40;&#41;</code> returns a <code>Float64</code></p> <li><p><code>rand&#40;&#41; &gt; 0.5</code> returns a <code>Bool</code></p> </ul> <p>Highlighted in yellow are &quot;small concrete unions&quot;, for example:</p> <ul> <li><p><code>T</code>, which is a union type of two types: <code>Union&#123;Type&#123;Float64&#125;, Type&#123;Int64&#125;&#125;</code></p> <li><p>our random array of size 100, which is a <code>Union&#123;Vector&#123;Float64&#125;, Vector&#123;Int64&#125;&#125;</code></p> <li><p>the return value of <code>sum</code>, which is a <code>Union&#123;Float64, Int64&#125;</code></p> </ul> <p><a href="https://julialang.org/blog/2018/08/union-splitting/">These union types are not always a problem</a>, as long as they don&#39;t result in a combinatorial explosion of possible types.</p> <p>A big disadvantage of <code>@code_warntype</code> is that it only shows us inferred types for the exact function call we applied the macro to. Type instabilities in inner functions calls are not always visible.</p> <h3 id=cthulhujl ><a href="#cthulhujl" class=header-anchor >Cthulhu.jl</a></h3> <div class="admonition warning"> <p class=admonition-title >Warning</p> <p>This is a tool for advanced users and might be confusing to beginners.</p> </div> <p><a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> is the advanced user&#39;s version of <code>@code_warntype</code>. It allows us to recursively &quot;descend deeper&quot; into our code until we find a point at which type inference failed.</p> <p>Calling <code>@descend</code> on a function will start a command-line interface to interactively explore our code with type-annotations. Since this interface is pretty dense in information, it can look intimidating:</p> <p><img src="/julia-ml-course/assets/cthulhu_1.png" alt="Cthulhu.jl example" /></p> <p>At the top of the output &#40;orange box&#41;, the original source code is shown with additional annotations of inferred types, e.g. <code>Union&#123;Float64, Int64&#125;</code>. By default, source code format is used, which can be nicer than <code>@code_warntype</code>&#39;s IR.</p> <p>The second section &#40;green box&#41; shows the interactive interface of Cthulhu.jl. The letters in <code>&#91; &#93;</code> brackets are the keys that need to be typed to toggle options. For example, pressing the <code>w</code> key will highlight union types in yellow and code with poor type inferability in red:</p> <p><img src="/julia-ml-course/assets/cthulhu_2.png" alt="Cthulhu.jl highlighting" /></p> <p>The bottom-most section &#40;purple box&#41; allows us to move deeper into the code. Using the arrow keys, the cursor <code>•</code> &#40;pink box&#41; can be moved to select a specific function call. Hitting enter will recursively &quot;descend&quot; into the code. To &quot;ascend&quot;, place the cursor over <code>↩</code> and hit enter.</p> <h2 id=acknowledgements ><a href="#acknowledgements" class=header-anchor >Acknowledgements</a></h2> <p>Snippets for profiling are taken from <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> and <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>. Many thanks to Théo Galy-Fajou for helpful discussions.</p> <div class=page-foot > Last modified: <a href="https://github.com/adrhill/julia-ml-course/commits/main">August 25, 2025.</a><br> Website, code and notebooks are under <a href="https://github.com/adrhill/julia-ml-course/blob/main/LICENSE">MIT License</a> &copy; <a href="http://adrianhill.de">Adrian Hill</a>.<br> Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, <a href="https://github.com/fonsp/Pluto.jl">Pluto.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> <script src="/julia-ml-course/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>